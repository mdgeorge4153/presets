MILKDROP_PRESET_VERSION=201
PSVERSION=2
PSVERSION_WARP=2
PSVERSION_COMP=2

[preset00]
fShader=0.0
fGammaAdj=1.980
warp=0
zoom=1

# disable built-in wave
wave_a=0

# custom wave
wavecode_1_enabled=1
wavecode_1_samples=500
wavecode_1_bSpectrum=0
wavecode_1_bUseDots=1
wavecode_1_bDrawThick=1
wavecode_1_smoothing=0.5

wave_1_init='''
    ball_x = .5;
    ball_y = .8;

    ball_vx = .15;
    ball_vy = 0;
'''

wave_1_per_frame='''
    dt = 1/fps;

    // motion
    ball_x = ball_x + ball_vx*dt;
    ball_y = ball_y + ball_vy*dt;

    ball_vy = ball_vy - .9*dt; // gravity

    // collision with left side
    is_left = below(ball_x, 0)*below(ball_vx,0);
    ball_x  = is_left*(-ball_x)  + (1-is_left)*ball_x;
    ball_vx = is_left*(-ball_vx) + (1-is_left)*ball_vx;

    // collision with right side
    is_right = above(ball_x, 1)*above(ball_vx,0);
    ball_x  = is_right*(2 - ball_x) + (1-is_right)*ball_x;
    ball_vx = is_right*(-ball_vx)   + (1-is_right)*ball_vx;

    // collision with floor
    is_below = below(ball_y, 0)*below(ball_vy,0);
    ball_y  = is_below*(-ball_y) + (1-is_below)*ball_y;
    ball_vy = is_below*(-ball_vy) + (1-is_below)*ball_vy;

    // collision with top
    is_above = above(ball_y, 1)*above(ball_vy,0);
    ball_y  = is_above*(2 - ball_y)  + (1-is_above)*ball_y;
    ball_vy = is_above*(-.1*ball_vy) + (1-is_above)*ball_vy;

    // set up for wave processing
    last_x=0;
    last_y=0;

    q1 = aspectx;
    q2 = aspecty;
'''

wave_1_per_point='''
    theta = rand(100);
    bx = ball_x + .020*sin(theta)*q1;
    by = ball_y + .020*cos(theta)*q2;

    // draw wave
    wx = sample/.9;
    wy = value1*.15 + .2;

    // collision detection and handling
    has_ball = below(last_x, ball_x)*(1-below(wx, ball_x))*(1-is_ball);

    norm_x = wy - last_y;
    norm_y = last_x - wx;
    len_norm = sqrt(norm_x*norm_x + norm_y*norm_y);
    norm_x = -norm_x/len_norm;
    norm_y = norm_y/len_norm;

    is_below = has_ball*below(ball_y, wy);
    ball_y  = (1-is_below)*ball_y  + is_below*(wy + (wy - ball_y));
    ball_vy = (1-is_below)*ball_vy + is_below*(wy*5);
    ball_vx = (1-is_below)*ball_vx + is_below*(.5*norm_x);

    // drawing

    is_ball = above(sample, .9);
    x = is_ball*bx + (1-is_ball)*wx;
    y = is_ball*by + (1-is_ball)*wy;
    monitor = is_ball;

    r = below(wx, ball_x-.01) + above(wx, ball_x+.01);

    last_x = wx;
    last_y = wy;
'''

wavecode_2_enabled=0
wavecode_2_samples=500
wavecode_2_bSpectrum=0
wavecode_2_bUseDots=0
wavecode_2_bDrawThick=1
wavecode_2_smoothing=0.5

wave_2_per_point='''
    x=sample/.9;
    y=value1*.15 + .2;
    r=below(x, ball_x-.01) + above(x, ball_x+.01);
'''


warp_='''
    shader_body {
        ret = tex2D(sampler_main, uv)*0.8;
    }
'''
